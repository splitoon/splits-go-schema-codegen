// Autogenerated Transaction - regenerate with splits-go-schema-codegen
// Force autogen by deleting the @SignedSource line.

package logic

import (
	"errors"
	"splits-go-api/auth/contexts"
	"splits-go-api/auth/policies"
	"splits-go-api/auth/rules"
	"splits-go-api/constants"
	"splits-go-api/db"
	"splits-go-api/db/models"
	p "splits-go-api/db/models/predicates"
	"splits-go-api/logic/privacy"
	"splits-go-api/logic/util"

	"context"
	"sync"
	"time"

	bolt "github.com/johnnadratowski/golang-neo4j-bolt-driver"
	e "github.com/johnnadratowski/golang-neo4j-bolt-driver/errors"
	// * START MANUAL SECTION *
	// * END MANUAL SECTION *
)

// * START MANUAL SECTION *

// * END MANUAL SECTION *

// === GENERATED FUNCTIONS ===

func checkTransactionAuth(
	conn *bolt.Conn,
	vc contexts.ViewerContext,
	pp policies.PrivacyPolicy,
	params context.Context,
	id string,
) (bool, error) {

	// Check context cache
	permMap := params.Value(constants.PermsKey).(map[string]map[string]bool)
	mutex := params.Value(constants.PermsMutexKey).(*sync.Mutex)
	mutex.Lock()
	perms, ok := permMap[id]
	if ok {
		if hasPerm, ok2 := perms[pp.GetName()]; ok2 {
			mutex.Unlock()
			return hasPerm, nil
		}
	} else {
		permMap[id] = map[string]bool{}
	}
	mutex.Unlock()

	authContext := rules.AuthContext{SrcID: id, Conn: conn}
	hasAuth, _, err := pp.CheckAuth(&vc, authContext)
	if err != nil {
		return false, err
	}
	mutex.Lock()
	perms = permMap[id]
	perms[pp.GetName()] = hasAuth
	mutex.Unlock()

	return hasAuth, nil
}

func createTransactionFieldQuery(
	conn *bolt.Conn,
	vc contexts.ViewerContext,
	params context.Context,
	id string,
	fields []string,
	q *models.TransactionQ,
) (*models.TransactionQ, []bool, error) {

	// Check the auth for the fields
	fieldCheck := make([]bool, len(fields))
	for i := range fields {
		fieldCheck[i] = true
	}
	// Add the fields to the query if appropriate auth
	for i, x := range fields {
		switch x {

		case "id":
			{
				hasAuth, err := checkTransactionAuth(conn, vc, privacy.TransactionPrivacyPolicy, params, id)
				if err != nil {
					return nil, nil, err
				}
				if hasAuth {
					q = q.ReturnID()
				} else {
					fieldCheck[i] = false
				}
			}
		case "name":
			{
				hasAuth, err := checkTransactionAuth(conn, vc, privacy.TransactionPrivacyPolicy, params, id)
				if err != nil {
					return nil, nil, err
				}
				if hasAuth {
					q = q.ReturnName()
				} else {
					fieldCheck[i] = false
				}
			}
		case "created_at":
			{
				hasAuth, err := checkTransactionAuth(conn, vc, privacy.TransactionPrivacyPolicy, params, id)
				if err != nil {
					return nil, nil, err
				}
				if hasAuth {
					q = q.ReturnCreatedAt()
				} else {
					fieldCheck[i] = false
				}
			}
		case "amount":
			{
				hasAuth, err := checkTransactionAuth(conn, vc, privacy.TransactionPrivacyPolicy, params, id)
				if err != nil {
					return nil, nil, err
				}
				if hasAuth {
					q = q.ReturnAmount()
				} else {
					fieldCheck[i] = false
				}
			}
		default:
			{
				fieldCheck[i] = false
				log.Warnf("invalid requested field: %%s-%%s", "Transaction", x)
			}
		}
	}
	return q, fieldCheck, nil
}

// GetTransactionByID retrives the fields of a specific Transaction.
// If there is insufficient authorization, the field will return null.
func GetTransactionByID(
	conn *bolt.Conn,
	vc contexts.ViewerContext,
	params context.Context,
	id string,
	fields []string,
) ([]interface{}, error) {

	// Generate the query
	q := models.TransactionQuery().
		WhereID(p.Equals(id))
	q, fieldCheck, err := createTransactionFieldQuery(conn, vc, params, id, fields, q)
	if err != nil {
		return nil, err
	}

	// Return nil if no fields to request
	if len(q.Return) == 0 {
		return nil, nil
	}

	// Execute the query
	var row []interface{}
	newConn := conn
	for i := 0; row == nil && i < constants.LogicRetryCount; i++ {
		row, err = q.GenOne(newConn)
		if _, isBoltErr := err.(*e.Error); isBoltErr {
			// Try a new connection
			(*newConn).Close()
			time.Sleep(time.Millisecond * constants.LogicRetryWait)
			c, _ := db.GetDriverConn()
			newConn = c
		}
	}
	*conn = *newConn
	if err != nil {
		return nil, err
	}

	// Check for the authed fields
	results := util.RemoveUnauthedFields(row, fieldCheck)

	return results, nil
}

// GetTransactionByIDBatcher wraps the GetTransactionByID request to be batched later.
func GetTransactionByIDBatcher(
	conn *bolt.Conn,
	vc contexts.ViewerContext,
	params context.Context,
	id string,
	fields []string,
) (*util.LogicGetWrapper, error) {

	// Generate the query
	q := models.TransactionQuery().
		WhereID(p.Equals(id))
	q, fieldCheck, err := createTransactionFieldQuery(conn, vc, params, id, fields, q)
	if err != nil {
		return nil, err
	}

	// Return nil if no fields to request
	if len(q.Return) == 0 {
		return nil, nil
	}

	batcher := new(util.LogicGetWrapper)
	batcher.Query = &q.Query
	batcher.EvalAuth = func(row []interface{}) []interface{} {
		return util.RemoveUnauthedFields(row, fieldCheck)
	}
	return batcher, nil
}

// GetTransactionGroups retrieves the ids of connected Groups.
func GetTransactionGroups(
	conn *bolt.Conn,
	vc contexts.ViewerContext,
	params context.Context,
	id string,
) ([]interface{}, error) {

	// Check auth
	hasAuth, err := checkTransactionAuth(conn, vc, privacy.TransactionPrivacyPolicy, params, id)
	if err != nil {
		return nil, err
	}
	if !hasAuth {
		return nil, errors.New("invalid auth for GetTransactionGroup")
	}
	// Build the query and execute it
	rows, stmt, err := models.TransactionQuery().
		WhereID(p.Equals(id)).
		QueryGroupTXN().
		QueryGroup().
		ReturnID().
		Gen(conn)

	if stmt != nil {
		defer stmt.Close()
	}
	if err != nil {
		return nil, err
	}

	ids, err := util.ExtractFirstFromRows(rows)
	return ids, err
}

// GetTransactionGroupsBatcher wraps the GetTransactionGroups request to be batched later.
func GetTransactionGroupsBatcher(
	conn *bolt.Conn,
	vc contexts.ViewerContext,
	params context.Context,
	id string,
) (*util.LogicGetWrapper, error) {

	// Check auth
	hasAuth, err := checkTransactionAuth(conn, vc, privacy.TransactionPrivacyPolicy, params, id)
	if err != nil {
		return nil, err
	}
	if !hasAuth {
		return nil, errors.New("invalid auth for GetTransactionGroup")
	}
	q := models.TransactionQuery().
		WhereID(p.Equals(id)).
		QueryGroupTXN().
		QueryGroup().
		ReturnID()

	batcher := new(util.LogicGetWrapper)
	batcher.Query = &q.Query
	batcher.EvalAuth = func(row []interface{}) []interface{} {
		return row
	}
	return batcher, nil
}

// GetTransactionUsers retrieves the ids of connected Users.
func GetTransactionUsers(
	conn *bolt.Conn,
	vc contexts.ViewerContext,
	params context.Context,
	id string,
) ([]interface{}, error) {

	// Check auth
	hasAuth, err := checkTransactionAuth(conn, vc, privacy.TransactionPrivacyPolicy, params, id)
	if err != nil {
		return nil, err
	}
	if !hasAuth {
		return nil, errors.New("invalid auth for GetTransactionUser")
	}
	// Build the query and execute it
	rows, stmt, err := models.TransactionQuery().
		WhereID(p.Equals(id)).
		QueryUserTXN().
		QueryUser().
		ReturnID().
		Gen(conn)

	if stmt != nil {
		defer stmt.Close()
	}
	if err != nil {
		return nil, err
	}

	ids, err := util.ExtractFirstFromRows(rows)
	return ids, err
}

// GetTransactionUsersBatcher wraps the GetTransactionUsers request to be batched later.
func GetTransactionUsersBatcher(
	conn *bolt.Conn,
	vc contexts.ViewerContext,
	params context.Context,
	id string,
) (*util.LogicGetWrapper, error) {

	// Check auth
	hasAuth, err := checkTransactionAuth(conn, vc, privacy.TransactionPrivacyPolicy, params, id)
	if err != nil {
		return nil, err
	}
	if !hasAuth {
		return nil, errors.New("invalid auth for GetTransactionUser")
	}
	q := models.TransactionQuery().
		WhereID(p.Equals(id)).
		QueryUserTXN().
		QueryUser().
		ReturnID()

	batcher := new(util.LogicGetWrapper)
	batcher.Query = &q.Query
	batcher.EvalAuth = func(row []interface{}) []interface{} {
		return row
	}
	return batcher, nil
}
