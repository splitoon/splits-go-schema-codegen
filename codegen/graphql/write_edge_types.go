package graphql

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"go/format"
	cg "splits-go-schema-codegen/codegen"
	"strings"
)

// WriteGQLEdgeResolverType writes the graphql node resolvers.
func WriteGQLEdgeResolverType(
	edge cg.GraphQLEdge,
	manualParts []string,
	packageName string,
) string {

	getManualPart := initManualPart(manualParts)

	// Use templates to generate the node
	sections := []string{}
	sections = append(sections, GetGQLEdgeResolverFileHeaderCommentStr())
	sections = append(sections, GetGQLEdgeResolverPackageStr(packageName))
	sections = append(sections, GetGQLEdgeResolverImportStr(getManualPart()))
	sections = append(sections, GetGQLEdgeResolverExtraFunctionsStr(
		getManualPart()))
	sections = append(sections, GetGQLEdgeResolverGeneratedFunctionsTagStr())
	sections = append(sections, GetGQLEdgeConnectionResolverStr(edge))
	sections = append(sections, GetGQLEdgeEdgeResolverStr(edge))
	result := strings.Join(sections, "\n")
	res, err := format.Source([]byte(result))
	if err != nil {
		fmt.Println(result)
		panic(err)
	}

	signatureRes := []byte(cg.ReplaceAllStringSubmatchFunc(
		cg.ManualExtractor,
		string(res),
		func(groups []string) string {
			return cg.StartManual + groups[2] + cg.EndManual
		},
	))

	// Generate the MD5 signature
	sum := md5.Sum([]byte(signatureRes))
	signature := hex.EncodeToString([]byte(sum[:]))

	// Add the signature to the top of the file
	return "// @SignedSource (" + signature + ")\n" + string(res)
}

// GetGQLEdgeResolverFileHeaderCommentStr generates an autogenerated tag.
func GetGQLEdgeResolverFileHeaderCommentStr() string {
	data := struct{}{}
	template := "// Autogenerated node type - regenerate with splits-go-schema-" +
		"codegen\n// Force autogen by deleting the @SignedSource line.\n"
	return cg.ExecTemplate(template, "edge_type_file_header_comment", data, nil)
}

// GetGQLEdgeResolverPackageStr generates the package string.
func GetGQLEdgeResolverPackageStr(packageName string) string {
	data := struct {
		Package string
	}{
		Package: packageName,
	}
	template := "package {{.Package}}\n"
	return cg.ExecTemplate(template, "edge_type_package_string", data, nil)
}

// GetGQLEdgeResolverImportStr generates the import block.
func GetGQLEdgeResolverImportStr(manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template := "import (\n" +
		"\tgraphql \"github.com/neelance/graphql-go\"\n" +
		"\n" +
		cg.StartManual + "\n" +
		"{{.ManualPart}}\n" +
		cg.EndManual + "\n" +
		")\n"
	return cg.ExecTemplate(template, "edge_type_import_string", data, nil)
}

// GetGQLEdgeResolverExtraFunctionsStr adds a manual sections for user defined
// functions.
func GetGQLEdgeResolverExtraFunctionsStr(manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template :=
		cg.StartManual + "\n" +
			"{{.ManualPart}}\n" +
			cg.EndManual + "\n"
	return cg.ExecTemplate(template, "edge_type_extra_functions", data, nil)
}

// GetGQLEdgeResolverGeneratedFunctionsTagStr writes a generated functions
// tagline.
func GetGQLEdgeResolverGeneratedFunctionsTagStr() string {
	return "// === GENERATED FUNCTIONS === \n"
}

// GetGQLEdgeConnectionResolverStr writes the resolver connection type.
func GetGQLEdgeConnectionResolverStr(e cg.GraphQLEdge) string {
	data := struct {
		From         string
		FromCodeName string
		To           string
		ToCodeName   string
		Var          string
	}{
		From:         e.From,
		To:           e.To,
		FromCodeName: e.FromCodeName,
		ToCodeName:   e.ToCodeName,
		Var: strings.ToLower(string(e.FromCodeName[0]) +
			string(e.ToCodeName[0])),
	}
	template := "// {{.FromCodeName}}To{{.ToCodeName}}ConnectionArgs are the " +
		"graphql connection args.\n" +
		"type {{.FromCodeName}}To{{.ToCodeName}}ConnectionArgs struct {\n" +
		"\tFirst *int32\n" +
		"\tAfter *graphql.ID\n" +
		"}\n" +
		"\n" +
		"// {{.FromCodeName}}To{{.ToCodeName}}ConnectionResolver is the graphql " +
		"connection resolver.\n" +
		"type {{.FromCodeName}}To{{.ToCodeName}}ConnectionResolver struct {\n" +
		"\tfromID string\n" +
		"\tids []graphql.ID\n" +
		"\tfrom int\n" +
		"\tto int\n" +
		"}\n" +
		"\n" +
		"// TotalCount gets the total number of ids in the edge.\n" +
		"func ({{.Var}} *{{.FromCodeName}}To{{.ToCodeName}}ConnectionResolver) " +
		"TotalCount() int32 {\n" +
		"\treturn int32(len({{.Var}}.ids))\n" +
		"}\n" +
		"\n" +
		"// Edges gets the edge resolvers.\n" +
		"func ({{.Var}} *{{.FromCodeName}}To{{.ToCodeName}}ConnectionResolver) " +
		"Edges() *[]*{{.FromCodeName}}To{{.ToCodeName}}EdgeResolver {\n" +
		"\tl := make([]*{{.FromCodeName}}To{{.ToCodeName}}EdgeResolver, " +
		"{{.Var}}.to-{{.Var}}.from)\n" +
		"\tfor i := range l {\n" +
		"\t\tl[i] = &{{.FromCodeName}}To{{.ToCodeName}}EdgeResolver{\n" +
		"\t\t\tcursor: encodeCursor({{.Var}}.from + i),\n" +
		"\t\t\tid:     {{.Var}}.ids[{{.Var}}.from+i],\n" +
		"\t\t\tfromID: {{.Var}}.fromID,\n" +
		"\t\t}\n" +
		"\t}\n" +
		"\treturn &l\n" +
		"}\n" +
		"\n" +
		"// Nodes gets the nodes on the other side of the edge.\n" +
		"func ({{.Var}} *{{.FromCodeName}}To{{.ToCodeName}}ConnectionResolver) " +
		"Nodes() *[]*{{.ToCodeName}}Resolver {\n" +
		"\tvar groups []*{{.ToCodeName}}Resolver\n" +
		"\tids := {{.Var}}.ids[{{.Var}}.from:{{.Var}}.to]\n" +
		"\tfor _, id := range ids {\n" +
		"\t\tgroups = append(groups, &{{.ToCodeName}}Resolver{string(id)})\n" +
		"\t}\n" +
		"\treturn &groups\n" +
		"}\n" +
		"\n" +
		"// PageInfo gets the pagination info about the connection.\n" +
		"func ({{.Var}} *{{.FromCodeName}}To{{.ToCodeName}}ConnectionResolver) " +
		"PageInfo() *PageInfoResolver {\n" +
		"return &PageInfoResolver{\n" +
		"startCursor: encodeCursor({{.Var}}.from),\n" +
		"endCursor:   encodeCursor({{.Var}}.to - 1),\n" +
		"hasNextPage: {{.Var}}.to < len({{.Var}}.ids),\n" +
		"}\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_connection_resolver_type", data, nil)
}

// GetGQLEdgeEdgeResolverStr writes the resolver type for the edge.
func GetGQLEdgeEdgeResolverStr(e cg.GraphQLEdge) string {
	fields := []cg.GraphQLField{}
	timeFields := []cg.GraphQLField{}
	for _, f := range e.Fields {
		if f.CodeType == "graphql.Time" {
			timeFields = append(timeFields, f)
			continue
		}
		fields = append(fields, f)
	}
	data := struct {
		From         string
		FromCodeName string
		To           string
		ToCodeName   string
		Var          string
		Fields       []cg.GraphQLField
		TimeFields   []cg.GraphQLField
		TotalName    string
		IsReverse    bool
	}{
		From:         e.From,
		To:           e.To,
		FromCodeName: e.FromCodeName,
		ToCodeName:   e.ToCodeName,
		Var: strings.ToLower(string(e.FromCodeName[0]) +
			string(e.ToCodeName[0])),
		Fields:     fields,
		TimeFields: timeFields,
		TotalName:  e.TotalName,
		IsReverse:  e.IsReverse,
	}
	template := "// {{.FromCodeName}}To{{.ToCodeName}}EdgeResolver is the " +
		"graphql edge resolver.\n" +
		"type {{.FromCodeName}}To{{.ToCodeName}}EdgeResolver struct {\n" +
		"\tcursor graphql.ID\n" +
		"\tid graphql.ID\n" +
		"\tfromID string\n" +
		"}\n" +
		"\n" +
		"// Cursor returns the current edge cursor.\n" +
		"func ({{.Var}} *{{.FromCodeName}}To{{.ToCodeName}}EdgeResolver) " +
		"Cursor() graphql.ID {\n" +
		"\treturn {{.Var}}.cursor\n" +
		"}\n" +
		"\n" +
		"// Node gets the node on the other side of the edge.\n" +
		"func ({{.Var}} *{{.FromCodeName}}To{{.ToCodeName}}EdgeResolver) " +
		"Node() *{{.ToCodeName}}Resolver {\n" +
		"\treturn &{{.ToCodeName}}Resolver{string({{.Var}}.id)}\n" +
		"}\n" +
		"\n" +

		// Regular fields

		"{{range .Fields}}" +
		"// {{.CodeName}} resolves the {{.Name}} field on the edge.\n" +
		"func ({{$.Var}} *{{$.FromCodeName}}To{{$.ToCodeName}}EdgeResolver) " +
		"{{.CodeName}}(ctx context.Context) (*{{.CodeType}}, error) {\n" +
		"\tfromID := {{$.Var}}.fromID\n" +
		"\ttoID := string({{$.Var}}.id)\n" +
		"\tdl := ctx.Value(constants.DataloaderKey).(*dataloader.Loader)\n" +
		"{{if $.IsReverse}}" +
		"\tthunk := dl.Load(ctx, muxField(\"{{$.TotalName}}\", toID + \"|\" + " +
		"fromID, \"{{.Name}}\"))\n" +
		"{{else}}" +
		"\tthunk := dl.Load(ctx, muxField(\"{{$.TotalName}}\", fromID + \"|\" + " +
		"toID, \"{{.Name}}\"))\n" +
		"{{end}}" +
		"\tval, err := thunk()\n" +
		"\t\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif val == nil {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"{{if eq .CodeType \"float64\"}}" +
		"\tvar res float64\n" +
		"\tswitch v := val.(type) {\n" +
		"\tcase float64:\n" +
		"\t\tres = v\n" +
		"\tcase int64:\n" +
		"\t\tres = float64(v)\n" +
		"\t\tdefault:\n" +
		"\t\treturn nil, errors.New(\"invalid float64 type casting\")\n" +
		"\t}\n" +
		"{{else}}" +
		"\tres := val.({{.CodeType}})\n" +
		"{{end}}" +
		"\treturn &res, nil\n" +
		"}\n" +
		"\n" +
		"{{end}}" +

		// Time fields
		"{{range .TimeFields}}" +
		"// {{.CodeName}} resolves the {{.Name}} field on the edge.\n" +
		"func ({{$.Var}} *{{$.FromCodeName}}To{{$.ToCodeName}}EdgeResolver) " +
		"{{.CodeName}}(ctx context.Context) (*graphql.Time, error){\n" +
		"\tfromID := {{$.Var}}.fromID\n" +
		"\ttoID := string({{$.Var}}.id)\n" +
		"\tdl := ctx.Value(constants.DataloaderKey).(*dataloader.Loader)\n" +
		"{{if $.IsReverse}}" +
		"\tthunk := dl.Load(ctx, muxField(\"{{$.TotalName}}\", toID + \"|\" + " +
		"fromID, \"{{.Name}}\"))\n" +
		"{{else}}" +
		"\tthunk := dl.Load(ctx, muxField(\"{{$.TotalName}}\", fromID + \"|\" + " +
		"toID, \"{{.Name}}\"))\n" +
		"{{end}}" +
		"\tval, err := thunk()\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif val == nil {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\ttimeValue := time.Unix(val.(int64), 0)\n" +
		"\treturn &graphql.Time{Time: timeValue}, nil\n" +
		"}\n" +
		"\n" +
		"{{end}}"
	return cg.ExecTemplate(template, "edge_edge_resolver_type", data, nil)
}
