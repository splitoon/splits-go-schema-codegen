package graphql

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"go/format"
	cg "splits-go-schema-codegen/codegen"
	"strings"
)

// WriteGQLNodeResolverType writes the graphql node resolvers.
func WriteGQLNodeResolverType(
	node cg.GraphQLNode,
	manualParts []string,
	packageName string,
) string {

	getManualPart := initManualPart(manualParts)

	// Use templates to generate the node
	sections := []string{}
	sections = append(sections, GetGQLNodeResolverFileHeaderCommentStr())
	sections = append(sections, GetGQLNodeResolverPackageStr(packageName))
	sections = append(sections, GetGQLNodeResolverImportStr(getManualPart()))
	sections = append(sections, GetGQLNodeResolverExtraFunctionsStr(
		getManualPart()))
	sections = append(sections, GetGQLNodeResolverGeneratedFunctionsTagStr())
	sections = append(sections, GetGQLNodeResolverStr(node))
	sections = append(sections, GetGQLNodeEdgeResolverStr(node))
	result := strings.Join(sections, "\n")
	res, err := format.Source([]byte(result))
	if err != nil {
		fmt.Println(result)
		panic(err)
	}

	signatureRes := []byte(cg.ReplaceAllStringSubmatchFunc(
		cg.ManualExtractor,
		string(res),
		func(groups []string) string {
			return cg.StartManual + groups[2] + cg.EndManual
		},
	))

	// Generate the MD5 signature
	sum := md5.Sum([]byte(signatureRes))
	signature := hex.EncodeToString([]byte(sum[:]))

	// Add the signature to the top of the file
	return "// @SignedSource (" + signature + ")\n" + string(res)
}

// GetGQLNodeResolverFileHeaderCommentStr generates an autogenerated tag.
func GetGQLNodeResolverFileHeaderCommentStr() string {
	data := struct{}{}
	template := "// Autogenerated node type - regenerate with splits-go-schema-" +
		"codegen\n// Force autogen by deleting the @SignedSource line.\n"
	return cg.ExecTemplate(template, "node_type_file_header_comment", data, nil)
}

// GetGQLNodeResolverPackageStr generates the package string.
func GetGQLNodeResolverPackageStr(packageName string) string {
	data := struct {
		Package string
	}{
		Package: packageName,
	}
	template := "package {{.Package}}\n"
	return cg.ExecTemplate(template, "node_type_package_string", data, nil)
}

// GetGQLNodeResolverImportStr generates the import block.
func GetGQLNodeResolverImportStr(manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template := "import (\n" +
		"\t\"context\"\n" +
		"\t\"splits-go-api/constants\"\n" +
		"\t\"splits-go-api/log\"\n" +
		"\n" +
		"\tgraphql \"github.com/neelance/graphql-go\"\n" +
		"\tdataloader \"gopkg.in/nicksrandall/dataloader.v2\"\n" +
		"\n" +
		cg.StartManual + "\n" +
		"{{.ManualPart}}\n" +
		cg.EndManual + "\n" +
		")\n"
	return cg.ExecTemplate(template, "node_type_import_string", data, nil)
}

// GetGQLNodeResolverExtraFunctionsStr adds a manual sections for user defined
// functions.
func GetGQLNodeResolverExtraFunctionsStr(manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template :=
		cg.StartManual + "\n" +
			"{{.ManualPart}}\n" +
			cg.EndManual + "\n"
	return cg.ExecTemplate(template, "node_type_extra_functions", data, nil)
}

// GetGQLNodeResolverGeneratedFunctionsTagStr writes a generated functions
// tagline.
func GetGQLNodeResolverGeneratedFunctionsTagStr() string {
	return "// === GENERATED FUNCTIONS === \n"
}

// GetGQLNodeResolverStr writes the resolver type.
func GetGQLNodeResolverStr(n cg.GraphQLNode) string {
	fields := []cg.GraphQLField{}
	timeFields := []cg.GraphQLField{}
	for _, f := range n.Fields {
		if f.CodeName == "ID" {
			continue
		}
		if f.CodeType == "graphql.Time" {
			timeFields = append(timeFields, f)
			continue
		}
		fields = append(fields, f)
	}
	data := struct {
		Node       cg.GraphQLNode
		Fields     []cg.GraphQLField
		TimeFields []cg.GraphQLField
		Name       string
		Var        string
	}{
		Node:       n,
		Fields:     fields,
		TimeFields: timeFields,
		Name:       n.CodeName,
		Var:        strings.ToLower(string(n.CodeName[0])),
	}
	template := "// {{.Name}}Resolver for resolving {{.Name}} nodes.\n" +
		"type {{.Name}}Resolver struct {\n" +
		"\tid string\n" +
		"}\n" +
		"\n" +
		"// =====================================================================" +
		"========\n" +
		"// Fields\n" +
		"// =====================================================================" +
		"========\n" +
		"\n" +

		// ID field

		"// ID resolves the id field for the {{$.Name}} type.\n" +
		"func ({{.Var}} *{{.Name}}Resolver) ID(ctx context.Context) (graphql.ID," +
		" error) {\n" +
		"\tid := {{.Var}}.id\n" +
		"\t// Check for auth first\n" +
		"\thasAuth, err := checkAuth(ctx, \"{{$.Name}}\", id, \"id\")\n" +
		"\tif err != nil {\n" +
		"\t\tlog.Warn(err)\n" +
		"\t\treturn \"\", err\n" +
		"\t}\n" +
		"\tif !hasAuth {\n" +
		"\treturn \"\", nil\n" +
		"\t}\n" +
		"\t\n" +
		"\t// Load the value\n" +
		"\tdl := ctx.Value(constants.DataloaderKey).(*dataloader.Loader)\n" +
		"\tthunk := dl.Load(ctx, muxField(\"{{$.Name}}\", id, \"id\"))\n" +
		"\tverifiedID, err := thunk()\n" +
		"\tif err != nil {\n" +
		"\t\treturn \"\", err\n" +
		"\t}\n" +
		"\tif verifiedID == nil {\n" +
		"\t\treturn \"\", err\n" +
		"\t}\n" +
		"\treturn graphql.ID(\"{{$.Name}}:\" + verifiedID.(string)), nil" +
		"}\n" +
		"\n" +

		// Regular fields

		"{{range .Fields}}" +
		"// {{.CodeName}} resolves the {{.Name}} field for the {{$.Name}} type.\n" +
		"func ({{$.Var}} *{{$.Name}}Resolver) {{.CodeName}}(ctx context.Context) " +
		"(*{{.CodeType}}, error) {\n" +
		"\tid := {{$.Var}}.id\n" +
		"\t\n" +
		"\t// Check for auth first\n" +
		"\thasAuth, err := checkAuth(ctx, \"{{$.Name}}\", id, \"{{.Name}}\")\n" +
		"\tif err != nil {\n" +
		"\t\tlog.Warn(err)\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif !hasAuth {\n" +
		"\treturn nil, nil\n" +
		"\t}\n" +
		"\t\n" +
		"\t// Load the value\n" +
		"\tdl := ctx.Value(constants.DataloaderKey).(*dataloader.Loader)\n" +
		"\tthunk := dl.Load(ctx, muxField(\"{{$.Name}}\", id, \"{{.Name}}\"))\n" +
		"\tval, err := thunk()\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif val == nil {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\tres := val.({{.CodeType}})\n" +
		"\treturn &res, nil\n" +
		"}\n" +
		"\n" +
		"{{end}}" +

		// Time fields

		"{{range .TimeFields}}" +
		"// {{.CodeName}} resolves the {{.Name}} field for the {{$.Name}} type.\n" +
		"func ({{$.Var}} *{{$.Name}}Resolver) {{.CodeName}}(ctx context.Context) " +
		"(*graphql.Time, error){\n" +
		"\tid := {{$.Var}}.id\n" +
		"\t\n" +
		"\t// Check for auth first\n" +
		"\thasAuth, err := checkAuth(ctx, \"{{$.Name}}\", id, \"{{.Name}}\")\n" +
		"\tif err != nil {\n" +
		"\t\tlog.Warn(err)\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif !hasAuth {\n" +
		"\treturn nil, nil\n" +
		"\t}\n" +
		"\t\n" +
		"\t// Load the value\n" +
		"\tdl := ctx.Value(constants.DataloaderKey).(*dataloader.Loader)\n" +
		"\tthunk := dl.Load(ctx, muxField(\"{{$.Name}}\", id, \"{{.Name}}\"))\n" +
		"\tval, err := thunk()\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif val == nil {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\ttimeValue := time.Unix(val.(int64), 0)\n" +
		"\treturn &graphql.Time{Time: timeValue}, nil\n" +
		"}\n" +
		"\n" +
		"{{end}}"
	return cg.ExecTemplate(template, "node_resolver_type", data, nil)
}

// GetGQLNodeEdgeResolverStr writes the resolvers for the edges.
func GetGQLNodeEdgeResolverStr(n cg.GraphQLNode) string {
	edges := n.Edges
	data := struct {
		Node  cg.GraphQLNode
		Edges []cg.GraphQLEdge
		Name  string
		Var   string
	}{
		Node:  n,
		Edges: edges,
		Name:  n.CodeName,
		Var:   strings.ToLower(string(n.CodeName[0])),
	}
	template := "// =====================================================================" +
		"========\n" +
		"// Edges\n" +
		"// =====================================================================" +
		"========\n" +
		"\n" +
		"{{range .Edges}}" +
		"// {{.FieldCodeName}} finds the connected edges.\n" +
		"func ({{$.Var}} *{{$.Name}}Resolver) {{.FieldCodeName}}(\n\t" +
		"ctx context.Context,\n\targs {{.FromCodeName}}To{{.ToCodeName}}" +
		"ConnectionArgs,\n) " +
		"(*{{.FromCodeName}}To{{.ToCodeName}}ConnectionResolver, error ) {\n" +
		"\tid := {{$.Var}}.id\n" +
		"\tdl := ctx.Value(constants.DataloaderKey).(*dataloader.Loader)\n" +
		"\tthunk := dl.Load(ctx, muxField(\"{{.FromCodeName}}" +
		"{{.ToCodeName}}\", id, " +
		"\"{{.FieldName}}\"))\n" +
		"\tpreIDList, err := thunk()\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif preIDList == nil {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\tidList := preIDList.([]interface{})\n" +
		"\tif idList == nil {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\tids := make([]graphql.ID, 0)\n" +
		"\tfor _, i := range idList {\n" +
		"\t\tids = append(ids, graphql.ID(i.(string)))\n" +
		"\t}\n" +

		"\t// ================\n" +
		"\t// CONNECTION STUFF\n " +
		"\t// ================\n" +
		"\t\n" +
		"\tfrom := 0\n" +
		"\tif args.After != nil {\n" +
		"\t\tb, err := base64.StdEncoding.DecodeString(string(*args.After))\n" +
		"\t\tif err != nil {\n" +
		"\t\t\treturn nil, err\n" +
		"\t\t}\n" +
		"\ti, err := strconv.Atoi(strings.TrimPrefix(string(b), \"cursor\"))\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tfrom = i\n" +
		"\t}\n" +
		"\t\n" +
		"\tto := len(ids)\n" +
		"\tif args.First != nil {\n" +
		"\t\tto = from + int(*args.First)\n" +
		"\t\tif to > len(ids) {\n" +
		"\t\t\tto = len(ids)\n" +
		"\t\t}\n" +
		"\t}\n" +
		"\t\n" +
		"\treturn &{{.From}}To{{.To}}ConnectionResolver{\n" +
		"\t\tfromID: id,\n" +
		"\t\tids:    ids,\n" +
		"\t\tfrom:   from,\n" +
		"\t\tto:     to,\n" +
		"\t}, nil\n" +
		"}\n" +
		"{{end}}"
	return cg.ExecTemplate(template, "node_edge_resolver_type", data, nil)
}
