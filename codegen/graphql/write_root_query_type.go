package graphql

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"go/format"
	cg "splits-go-schema-codegen/codegen"
	"strings"
)

// WriteRootQueryType writes the graphql base root query.
func WriteRootQueryType(
	schemas []cg.Schema,
	schema cg.GraphQLSchema,
	manualParts []string,
	packageName string,
) string {

	getManualPart := initManualPart(manualParts)

	// Use templates to generate the node
	sections := []string{}
	sections = append(sections, GetRootQueryTypeFileHeaderCommentStr())
	sections = append(sections, GetRootQueryTypePackageStr(packageName))
	sections = append(sections, GetRootQueryTypeImportStr(getManualPart()))
	sections = append(sections, GetRootQueryTypeExtraFunctionsStr(getManualPart()))
	sections = append(sections, GetRootQueryTypeGeneratedFunctionsTagStr())
	sections = append(sections, GetRootQueryTypeStr(schema))
	result := strings.Join(sections, "\n")
	res, err := format.Source([]byte(result))
	if err != nil {
		fmt.Println(result)
		panic(err)
	}

	signatureRes := []byte(cg.ReplaceAllStringSubmatchFunc(
		cg.ManualExtractor,
		string(res),
		func(groups []string) string {
			return cg.StartManual + groups[2] + cg.EndManual
		},
	))

	// Generate the MD5 signature
	sum := md5.Sum([]byte(signatureRes))
	signature := hex.EncodeToString([]byte(sum[:]))

	// Add the signature to the top of the file
	return "// @SignedSource (" + signature + ")\n" + string(res)
}

// GetRootQueryTypeFileHeaderCommentStr generates an autogenerated tag.
func GetRootQueryTypeFileHeaderCommentStr() string {
	data := struct{}{}
	template := "// Autogenerated node type - regenerate with splits-go-schema-" +
		"codegen\n// Force autogen by deleting the @SignedSource line.\n"
	return cg.ExecTemplate(template, "node_type_file_header_comment", data, nil)
}

// GetRootQueryTypePackageStr generates the package string.
func GetRootQueryTypePackageStr(packageName string) string {
	data := struct {
		Package string
	}{
		Package: packageName,
	}
	template := "package {{.Package}}\n"
	return cg.ExecTemplate(template, "node_type_package_string", data, nil)
}

// GetRootQueryTypeImportStr generates the import block.
func GetRootQueryTypeImportStr(manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template := "import (\n" +
		"\t\"context\"\n" +
		"\t\"splits-go-api/constants\"\n" +
		"\n" +
		"\tdataloader \"gopkg.in/nicksrandall/dataloader.v2\"\n" +
		"\n" +
		cg.StartManual + "\n" +
		"{{.ManualPart}}\n" +
		cg.EndManual + "\n" +
		")\n"
	return cg.ExecTemplate(template, "node_type_import_string", data, nil)
}

// GetRootQueryTypeExtraFunctionsStr adds a manual sections for user defined
// functions.
func GetRootQueryTypeExtraFunctionsStr(manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template :=
		cg.StartManual + "\n" +
			"{{.ManualPart}}\n" +
			cg.EndManual + "\n"
	return cg.ExecTemplate(template, "node_type_extra_functions", data, nil)
}

// GetRootQueryTypeGeneratedFunctionsTagStr writes a generated functions
// tagline.
func GetRootQueryTypeGeneratedFunctionsTagStr() string {
	return "// === GENERATED FUNCTIONS === \n"
}

// GetRootQueryTypeStr writes the node interface and resolver types.
func GetRootQueryTypeStr(s cg.GraphQLSchema) string {
	data := struct {
		Nodes []cg.GraphQLNode
		Edges []cg.GraphQLEdge
	}{
		Nodes: s.Nodes,
		Edges: s.Edges,
	}
	template := "// Resolver root for graphql queries.\n" +
		"type Resolver struct {}\n" +
		"\n" +
		"{{range .Nodes}}" +
		"// {{.CodeName}} is the root query resolver for a specific " +
		"{{.CodeName}}.\n" +
		"func (r *Resolver) {{.CodeName}}(\n\tctx context.Context,\n\t" +
		"args idArg,\n) (*{{.CodeName}}Resolver, error) {" +
		"\tpreDemuxID := args.ID\n" +
		"\t_, id, err := demuxKindAndID(preDemuxID)\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"dl := ctx.Value(constants.DataloaderKey).(*dataloader.Loader)\n" +
		"\tthunk := dl.Load(ctx, muxField(\"{{.CodeName}}\", id, \"id\"))\n" +
		"\tverifiedID, err := thunk()\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"}\n" +
		"\tif verifiedID == nil {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\treturn &{{.CodeName}}Resolver{verifiedID.(string)}, nil\n" +
		"}\n" +
		"\n" +
		"{{end}}"
	return cg.ExecTemplate(template, "root_query_type", data, nil)
}
