// The writer assumes a valid schema. The generation involves creating manual
// sections of code, as well as implementing getters that respect privacy for
// all the fields.

package logic

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"go/format"
	"splits-go-api/auth/policies"
	cg "splits-go-schema-codegen/codegen"
	"strings"
)

func initManualPart(manualParts []string) func() string {
	index := 0
	return func() string {
		if manualParts == nil {
			return ""
		}
		if index >= len(manualParts) {
			return ""
		}
		index++
		return strings.Replace(manualParts[index-1], "%", "%%", -1)
	}
}

// WriteSchemaLogicNode writes the logic for a node.
func WriteSchemaLogicNode(
	s cg.Schema,
	manualParts []string,
	packageName string,
) string {

	getManualPart := initManualPart(manualParts)

	// Use templates to generate the node
	sections := make([]string, 0, 11)
	sections = append(sections, GetFileHeaderCommentStr(s))
	sections = append(sections, GetPackageStr(s, packageName))
	sections = append(sections, GetNodeImportStr(s, getManualPart()))
	sections = append(sections, GetExtraFunctionsStr(s, getManualPart()))
	sections = append(sections, GetGeneratedFunctionsTagStr())
	sections = append(sections, GetNodeAuthMap(s))
	sections = append(sections, GetNodeFieldQueryStr(s))
	sections = append(sections, GetNodeGetByIDStr(s))
	sections = append(sections, GetNodeGetByIDBatchStr(s))
	sections = append(sections, GetNodeConnectedNodesStr(s))
	sections = append(sections, GetNodeWriteFieldQueryStr(s))
	sections = append(sections, GetUpdateNodeGetByIDStr(s))
	sections = append(sections, GetDeleteNodeByIDStr(s))
	result := strings.Join(sections, "\n")
	res, err := format.Source([]byte(result))
	if err != nil {
		fmt.Println(result)
		panic(err)
	}

	signatureRes := []byte(cg.ReplaceAllStringSubmatchFunc(
		cg.ManualExtractor,
		string(res),
		func(groups []string) string {
			return cg.StartManual + groups[2] + cg.EndManual
		},
	))

	// Generate the MD5 signature
	sum := md5.Sum([]byte(signatureRes))
	signature := hex.EncodeToString([]byte(sum[:]))

	// Add the signature to the top of the file
	return "// @SignedSource (" + signature + ")\n" + string(res)
}

// WriteSchemaLogicEdge writes the logic for a n edge.
func WriteSchemaLogicEdge(
	s cg.Schema,
	e cg.EdgeStruct,
	manualParts []string,
	packageName string,
) string {
	getManualPart := initManualPart(manualParts)

	// Use templates to generate the node
	sections := make([]string, 0, 11)
	sections = append(sections, GetFileHeaderCommentStr(s))
	sections = append(sections, GetPackageStr(s, packageName))
	sections = append(sections, GetEdgeImportStr(s, getManualPart()))
	sections = append(sections, GetExtraFunctionsStr(s, getManualPart()))
	sections = append(sections, GetGeneratedFunctionsTagStr())
	sections = append(sections, GetEdgeAuthMap(s, e))
	sections = append(sections, GetEdgeFieldQueryStr(s, e))
	sections = append(sections, GetEdgeGetByIDStr(s, e))
	sections = append(sections, GetEdgeGetByIDBatcherStr(s, e))
	sections = append(sections, GetEdgeGetByIDsStr(s, e))
	sections = append(sections, GetEdgeGetByIDsBatcherStr(s, e))
	sections = append(sections, GetEdgeWriteFieldQueryStr(s, e))
	sections = append(sections, GetUpdateEdgeGetByIDStr(s, e))
	sections = append(sections, GetUpdateEdgeGetByIDsStr(s, e))
	result := strings.Join(sections, "\n")
	res, err := format.Source([]byte(result))
	if err != nil {
		fmt.Println(result)
		panic(err)
	}

	signatureRes := []byte(cg.ReplaceAllStringSubmatchFunc(
		cg.ManualExtractor,
		string(res),
		func(groups []string) string {
			return cg.StartManual + groups[2] + cg.EndManual
		},
	))

	// Generate the MD5 signature
	sum := md5.Sum([]byte(signatureRes))
	signature := hex.EncodeToString([]byte(sum[:]))

	// Add the signature to the top of the file
	return "// @SignedSource (" + signature + ")\n" + string(res)
}

// GetFileHeaderCommentStr generates an autogenerated tag.
func GetFileHeaderCommentStr(s cg.Schema) string {
	data := struct {
		Name string
	}{
		Name: s.GetName(),
	}
	template := "// Autogenerated {{.Name}} - regenerate with splits-go-schema-" +
		"codegen\n// Force autogen by deleting the @SignedSource line.\n"
	return cg.ExecTemplate(template, "file_header_comment", data)
}

// GetPackageStr generates the package string.
func GetPackageStr(s cg.Schema, packageName string) string {
	data := struct {
		Package string
	}{
		Package: packageName,
	}
	template := "package {{.Package}}\n"
	return cg.ExecTemplate(template, "package_string", data)
}

// GetExtraFunctionsStr adds a manual sections for user defined functions.
func GetExtraFunctionsStr(s cg.Schema, manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template :=
		cg.StartManual + "\n" +
			"{{.ManualPart}}\n" +
			cg.EndManual + "\n"

	return cg.ExecTemplate(template, "extra_functions", data)
}

// GetGeneratedFunctionsTagStr writes a generated functions tagline.
func GetGeneratedFunctionsTagStr() string {
	return "// === GENERATED FUNCTIONS === \n"
}

// =============================================================================
// Node
// =============================================================================

// GetNodeImportStr generates the import block.
func GetNodeImportStr(s cg.Schema, manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template := "import (\n" +
		"\t\"splits-go-api/auth/contexts\"\n" +
		"\t\"splits-go-api/auth/policies\"\n" +
		"\t\"splits-go-api/constants\"\n" +
		"\t\"splits-go-api/db\"\n" +
		"\t\"splits-go-api/db/models\"\n" +
		"\tp \"splits-go-api/db/models/predicates\"\n" +
		"\t\"splits-go-api/log\"\n" +
		"\t\"splits-go-api/logic/privacy\"\n" +
		"\t\"splits-go-api/logic/util\"\n" +
		"\n" +
		"\t\"context\"\n" +
		"\t\"errors\"\n" +
		"\t\"time\"\n" +
		"\n" +
		cg.StartManual + "\n" +
		"{{.ManualPart}}\n" +
		cg.EndManual + "\n" +
		")\n"
	return cg.ExecTemplate(template, "node_import_string", data)
}

// GetNodeAuthMap generates the mapping of fields to auth policies
func GetNodeAuthMap(s cg.Schema) string {
	data := struct {
		Name            string
		Fields          []cg.FieldStruct
		DeletionPrivacy policies.PrivacyPolicy
	}{
		Name:            s.GetName(),
		Fields:          s.GetFields(),
		DeletionPrivacy: s.GetDeletionPrivacy(),
	}
	template := "// {{.Name}}AuthMap maps a field to the corresponding read " +
		"privacy policy.\n" +
		"var {{.Name}}AuthMap = map[string]policies.PrivacyPolicy{\n" +
		"{{range .Fields}}" +
		"\t\"{{.Name}}\": privacy.{{.Privacy.GetName}},\n" +
		"{{end}}" +
		"}\n" +
		"\n" +
		"// {{.Name}}WriteAuthMap maps a field to the corresponding write privacy " +
		"policy.\n" +
		"var {{.Name}}WriteAuthMap = map[string]policies.PrivacyPolicy{\n" +
		"{{range .Fields}}" +
		"\t\"{{.Name}}\": privacy.{{.WritePrivacy.GetName}},\n" +
		"{{end}}" +
		"}\n" +
		"\n" +
		"// {{.Name}}DeleteAuth is the privacy policy for deleting the node.\n" +
		"var {{.Name}}DeleteAuth = privacy.{{.DeletionPrivacy.GetName}}\n" +
		"\n"
	return cg.ExecTemplate(template, "node_auth_map", data)
}

// GetNodeFieldQueryStr creates a function that generates a query for the
// specified fields.
func GetNodeFieldQueryStr(s cg.Schema) string {
	fields := s.GetFields()
	data := struct {
		Name   string
		Fields []cg.FieldStruct
	}{
		Name:   s.GetName(),
		Fields: fields,
	}
	template := "func create{{.Name}}FieldQuery(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\tfields []string,\n" +
		"\tq *models.{{.Name}}Q,\n" +
		") (*models.{{.Name}}Q, []bool, error) {\n" +
		"\n" +
		"\t// Check the auth for the fields\n" +
		"\tfieldCheck := make([]bool, len(fields))\n" +
		"\tfor i := range fields {\n" +
		"\t\tfieldCheck[i] = true\n" +
		"\t}" +
		"\n" +
		"\t// Add the fields to the query if appropriate auth\n" +
		"\tfor i, x := range fields {\n" +
		"\t\tvar hasAuth bool\n" +
		"\t\tvar err error\n" +
		"\t\tif pp, ok := {{$.Name}}AuthMap[x]; !ok {\n" +
		"\t\t\tlog.Warnf(\"invalid requested field: %%s-%%s\", \"{{$.Name}}\", " +
		"x)\n" +
		"\t\t\tfieldCheck[i] = false\n" +
		"\t\t} else {\n" +
		"\t\t\thasAuth, err = util.CheckNodeAuth(conn, vc, pp, params, " +
		"\"{{$.Name}}\", id)\n" +
		"\t\t\tif err != nil {\n" +
		"\t\t\t\treturn nil, nil, err\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t\tif !hasAuth {\n" +
		"\t\t\tfieldCheck[i] = false\n" +
		"\t\t} else {\n" +
		"\t\t\tswitch x {\n\n" +
		"{{range .Fields}}" +
		"\t\t\tcase \"{{.Name}}\":\n" +
		"\t\t\t\tq = q.Return{{.CodeName}}()\n" +
		"{{end}}" +
		"\t\t\tdefault:\n" +
		"\t\t\t\t{\n" +
		"\t\t\t\t\tfieldCheck[i] = false\n" +
		"\t\t\t\t\tlog.Warnf(\"invalid requested field: %%s-%%s\", \"{{$.Name}}\", " +
		"x)\n" +
		"\t\t\t\t}\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t}\n" +
		"\treturn q, fieldCheck, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "node_field_query", data)
}

// GetNodeGetByIDStr gets the function that retrieves fields by the id of the
// node.
func GetNodeGetByIDStr(s cg.Schema) string {
	fields := s.GetFields()
	data := struct {
		Name   string
		Fields []cg.FieldStruct
	}{
		Name:   s.GetName(),
		Fields: fields,
	}
	template := "// Get{{.Name}}ByID retrives the fields of a specific " +
		"{{.Name}}.\n" +
		"// If there is insufficient authorization, the field will return null.\n" +
		"func Get{{.Name}}ByID(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\tfields []string,\n" +
		") ([]interface{}, error) {\n" +
		"\n" +
		"\t// Generate the query\n" +
		"\t q := models.{{.Name}}Query().\n" +
		"\t\tWhereID(p.Equals(id))\n" +
		"\tq, fieldCheck, err := create{{.Name}}FieldQuery(conn, vc, params, id, " +
		"fields, q)\n" +
		"\tif err != nil {\n" +
		"\t return nil, err\n" +
		"\t}\n" +
		"\n" +
		"\t// Return nil if no fields to request\n" +
		"\tif len(q.Return) == 0 {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\n" +
		"\t// Execute the query\n" +
		"\tvar row []interface{}\n" +
		"\tfor i := 0; row == nil && i < constants.LogicRetryCount; i++ {\n" +
		"\t\trow, err = q.GenOne(conn)\n" +
		"\t\t// Try a new connection\n" +
		"\t\ttime.Sleep(time.Millisecond * constants.LogicRetryWait)\n" +
		"\t\tconn.Refresh()\n" +
		"\t\n" +
		"\t}\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\t// Check for the authed fields\n" +
		"\tresults := util.RemoveUnauthedFields(row, fieldCheck)\n" +
		"\n" +
		"\treturn results, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "node_by_id", data)
}

// GetNodeGetByIDBatchStr generates the GetByID batcher
func GetNodeGetByIDBatchStr(s cg.Schema) string {
	fields := s.GetFields()
	data := struct {
		Name   string
		Fields []cg.FieldStruct
	}{
		Name:   s.GetName(),
		Fields: fields,
	}
	template := "// Get{{.Name}}ByIDBatcher wraps the Get{{.Name}}ByID request " +
		"to be batched later.\n" +
		"func Get{{.Name}}ByIDBatcher(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\tfields []string,\n" +
		") (*util.LogicGetWrapper, error) {\n" +
		"\n" +
		"\t// Generate the query\n" +
		"\t q := models.{{.Name}}Query().\n" +
		"\t\tWhereID(p.Equals(id))\n" +
		"\tq, fieldCheck, err := create{{.Name}}FieldQuery(conn, vc, params, id, " +
		"fields, q)\n" +
		"\tif err != nil {\n" +
		"\t return nil, err\n" +
		"\t}\n" +
		"\n" +
		"\t// Return nil if no fields to request\n" +
		"\tif len(q.Return) == 0 {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\n" +
		"\tbatcher := new(util.LogicGetWrapper)\n" +
		"\tbatcher.Query = &q.Query\n" +
		"\tbatcher.EvalAuth = func(row []interface{}) []interface{} {\n" +
		"\t\treturn util.RemoveUnauthedFields(row, fieldCheck)\n" +
		"\t}\n" +
		"\treturn batcher, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "node_by_id_batch", data)
}

// GetNodeConnectedNodesStr generates the function that gets connected
// corresponding node ids. This also writes the corresponding batch wrapper.
func GetNodeConnectedNodesStr(s cg.Schema) string {

	type NamePrivacyPair struct {
		Name      string
		QueryName string
		Privacy   policies.PrivacyPolicy
	}

	// Extract the edge name to the node name
	edges := map[string]NamePrivacyPair{}
	for _, e := range s.GetEdges() {
		if e.ToNode.GetName() == s.GetName() { // group->user
			edges[e.CodeName] = NamePrivacyPair{e.BackwardsName,
				e.FromNode.GetName(),
				e.ReversePrivacy}
		} else if e.FromNode.GetName() == s.GetName() {
			edges[e.CodeName] = NamePrivacyPair{e.ForwardsName,
				e.ToNode.GetName(),
				e.Privacy}
		}
	}
	for _, e := range s.GetEdgePointers() {
		if e.ToNode.GetName() == s.GetName() { // group->user
			edges[e.CodeName] = NamePrivacyPair{e.BackwardsName,
				e.FromNode.GetName(),
				e.ReversePrivacy}
		} else if e.FromNode.GetName() == s.GetName() {
			edges[e.CodeName] = NamePrivacyPair{e.ForwardsName,
				e.ToNode.GetName(),
				e.Privacy}
		}
	}

	data := struct {
		Name       string
		EdgeToNode map[string]NamePrivacyPair
	}{
		Name:       s.GetName(),
		EdgeToNode: edges,
	}
	template := "{{range $edgeName, $value := .EdgeToNode}}" +
		"// Get{{$.Name}}{{$value.Name}} retrieves the ids of connected " +
		"{{$value.Name}}s.\n" +
		"func Get{{$.Name}}{{$value.Name}}(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		") ([]interface{}, error) {\n" +
		"\n" +
		"\t// Check auth\n" +
		"\thasAuth, err := util.CheckNodeAuth(conn, vc, " +
		"privacy.{{$value.Privacy.GetName}}, \n\t\tparams, \"{{$.Name}}\", id)\n" +
		"\tif err != nil{\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif !hasAuth {\n" +
		"\t\treturn nil, errors.New(\"invalid auth for " +
		"Get{{$.Name}}{{$value.Name}}\")\n" +
		"\t}" +
		"\n" +
		"\t// Build the query and execute it\n" +
		"\trows, stmt, err := models.{{$.Name}}Query().\n" +
		"\t\tWhereID(p.Equals(id)).\n" +
		"\t\tQuery{{$edgeName}}().\n" +
		"\t\tQuery{{$value.QueryName}}().\n" +
		"\t\tReturnID().\n" +
		"\t\tGen(conn)\n" +
		"\n" +
		"\tif stmt != nil {\n" +
		"\t\tdefer stmt.Close()\n" +
		"\t}\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\tids, err := util.ExtractFirstFromRows(rows)\n" +
		"\treturn ids, err\n" +
		"}\n\n" +
		"// Get{{$.Name}}{{$value.Name}}Batcher wraps the Get{{$.Name}}" +
		"{{$value.Name}}s request to be batched later.\n" +
		"func Get{{$.Name}}{{$value.Name}}Batcher(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		") (*util.LogicGetWrapper, error) {\n" +
		"\n" +
		"\t// Check auth\n" +
		"\thasAuth, err := util.CheckNodeAuth(conn, vc, " +
		"privacy.{{$value.Privacy.GetName}}, \n\t\tparams, \"{{$.Name}}\", id)\n" +
		"\tif err != nil{\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif !hasAuth {\n" +
		"\t\treturn nil, errors.New(\"invalid auth for " +
		"Get{{$.Name}}{{$value.Name}}\")\n" +
		"\t}" +
		"\n" +
		"\tq := models.{{$.Name}}Query().\n" +
		"\t\tWhereID(p.Equals(id)).\n" +
		"\t\tQuery{{$edgeName}}().\n" +
		"\t\tQuery{{$value.QueryName}}().\n" +
		"\t\tReturnID()\n" +
		"\n" +
		"\tbatcher := new(util.LogicGetWrapper)\n" +
		"\tbatcher.Query = &q.Query\n" +
		"\tbatcher.EvalAuth = func(row []interface{}) []interface{} {\n" +
		"\t\treturn row\n" +
		"\t}\n" +
		"\treturn batcher, nil\n" +
		"}\n\n" +
		"{{end}}"

	return cg.ExecTemplate(template, "node_connected_nodes", data)
}

// GetNodeWriteFieldQueryStr creates a function that generates a query for the
// modifying specified fields.
func GetNodeWriteFieldQueryStr(s cg.Schema) string {
	fields := s.GetFields()
	data := struct {
		Name   string
		Fields []cg.FieldStruct
	}{
		Name:   s.GetName(),
		Fields: fields,
	}
	template := "func create{{.Name}}WriteFieldQuery(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\tfields map[string]interface{},\n" +
		"\tq *models.{{.Name}}M,\n" +
		") (*models.{{.Name}}M, []string, error) {\n" +
		"\n" +
		"\t// Keep track of the mutated fields\n" +
		"\tmutatedFields := []string{}\n" +
		"\n" +
		"\t// Add the fields to the query if appropriate auth\n" +
		"\tfor field, x := range fields {\n" +
		"\t\tvar hasAuth bool\n" +
		"\t\tvar err error\n" +
		"\t\tif pp, ok := {{$.Name}}AuthMap[field]; !ok {\n" +
		"\t\t\tlog.Warnf(\"invalid requested field: %%s-%%s\", \"{{$.Name}}\", " +
		"x)\n" +
		"\t\t} else {\n" +
		"\t\t\thasAuth, err = util.CheckNodeAuth(conn, vc, pp, params, " +
		"\"{{$.Name}}\", id)\n" +
		"\t\t\tif err != nil {\n" +
		"\t\t\t\treturn nil, nil, err\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t\tif hasAuth {\n" +
		"\t\t\tswitch field {\n\n" +
		"{{range .Fields}}" +
		"\t\t\tcase \"{{.Name}}\":\n" +
		"\t\t\t\t{\n" +
		"\t\t\t\t\tq = q.Set{{.CodeName}}(x.({{.Type}}))\n" +
		"\t\t\t\t\tmutatedFields = append(mutatedFields, field)\n" +
		"\t\t\t\t}\n" +
		"{{end}}" +
		"\t\t\tdefault:\n" +
		"\t\t\t\t{\n" +
		"\t\t\t\t\tlog.Warnf(\"invalid requested field: %%s-%%s\", \"{{$.Name}}\", " +
		"x)\n" +
		"\t\t\t\t}\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t}\n" +
		"\treturn q, mutatedFields, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "node_write_field_query", data)
}

// GetUpdateNodeGetByIDStr gets the function that updates fields by the id of
// the node.
func GetUpdateNodeGetByIDStr(s cg.Schema) string {
	fields := s.GetFields()
	data := struct {
		Name   string
		Fields []cg.FieldStruct
	}{
		Name:   s.GetName(),
		Fields: fields,
	}
	template := "// Update{{.Name}}ByID updates the fields of a specific " +
		"{{.Name}}.\n" +
		"// If there is insufficient authorization, the field will not be " +
		"returned.\n" +
		"func Update{{.Name}}ByID(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\tfields map[string]interface{},\n" +
		") ([]string, error) {\n" +
		"\n" +
		"\t// Generate the query\n" +
		"\tq := models.{{.Name}}Mutator(id)\n" +
		"\tq, mutatedFields, err := create{{.Name}}WriteFieldQuery(conn, vc, " +
		"params, id, " +
		"fields, q)\n" +
		"\tif err != nil {\n" +
		"\t return nil, err\n" +
		"\t}\n" +
		"\n" +
		"\t// Execute the query\n" +
		"\tvar row interface{}\n" +
		"\tfor i := 0; row == nil && i < constants.LogicRetryCount; i++ {\n" +
		"\t\trow, _, err = q.Gen(conn)\n" +
		"\t\t// Try a new connection\n" +
		"\t\ttime.Sleep(time.Millisecond * constants.LogicRetryWait)\n" +
		"\t\tconn.Refresh()\n" +
		"\t}\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\treturn mutatedFields, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "node_write_by_id", data)
}

// GetDeleteNodeByIDStr deletes a node by its id.
func GetDeleteNodeByIDStr(s cg.Schema) string {
	data := struct {
		Name string
	}{
		Name: s.GetName(),
	}
	template := "// Delete{{.Name}}ByID deletes the node and its corresponding " +
		"edges.\n" +
		"// Auth is also respected, otherwise no action will take place.\n" +
		"func Delete{{.Name}}ByID(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		") error {\n" +
		"\n" +
		"\t// Check for auth\n" +
		"\tpp := {{.Name}}DeleteAuth\n" +
		"\thasAuth, err := util.CheckNodeAuth(conn, vc, pp, params, " +
		"\"{{.Name}}\", id)\n" +
		"\tif err != nil {\n" +
		"\t\treturn err\n" +
		"\t}\n" +
		"\n" +
		"\tif !hasAuth { // No auth to delete the node\n" +
		"\t\treturn errors.New(\"no auth to delete {{.Name}} node\")\n" +
		"\t}" +
		"\n" +
		"\tres, stmt, err := models.{{.Name}}Deleter().\n" +
		"\t\tWhereID(p.Equals(id)).\n" +
		"\t\tDelete().\n" +
		"\t\tGen(conn)\n" +
		"\tif stmt != nil {\n" +
		"\t\tdefer stmt.Close()\n" +
		"\t}\n" +
		"\tif err != nil {\n" +
		"\t\t return err\n" +
		"\t}\n" +
		"\tif val, ok := res.Metadata()[\"result_available_after\"]; ok && " +
		"val.(int64) >= 0 {\n" +
		"\t\treturn nil\n" +
		"\t}\n" +
		"\t return errors.New(\"could not delete {{.Name}}: \" + id)\n" +
		"}\n"
	return cg.ExecTemplate(template, "node_delete_by_id", data)
}

// =============================================================================
// Edges
// =============================================================================

// GetEdgeImportStr generates the import block.
func GetEdgeImportStr(s cg.Schema, manualPart string) string {
	data := struct {
		ManualPart string
	}{
		ManualPart: manualPart,
	}
	template := "import (\n" +
		"\t\"splits-go-api/auth/contexts\"\n" +
		"\t\"splits-go-api/auth/policies\"\n" +
		"\t\"splits-go-api/constants\"\n" +
		"\t\"splits-go-api/db\"\n" +
		"\t\"splits-go-api/db/models\"\n" +
		"\tp \"splits-go-api/db/models/predicates\"\n" +
		"\t\"splits-go-api/log\"\n" +
		"\t\"splits-go-api/logic/privacy\"\n" +
		"\t\"splits-go-api/logic/util\"\n" +
		"\n" +
		"\t\"context\"\n" +
		"\t\"errors\"\n" +
		"\t\"time\"\n" +
		"\n" +
		cg.StartManual + "\n" +
		"{{.ManualPart}}\n" +
		cg.EndManual + "\n" +
		")\n"
	return cg.ExecTemplate(template, "edge_import_string", data)
}

// GetEdgeAuthMap generates the mapping of fields to auth policies
func GetEdgeAuthMap(s cg.Schema, e cg.EdgeStruct) string {
	data := struct {
		Name            string
		Fields          []cg.EdgeFieldStruct
		DeletionPrivacy policies.PrivacyPolicy
	}{
		Name:            e.CodeName,
		Fields:          e.Fields,
		DeletionPrivacy: e.DeletionPrivacy,
	}
	template := "// {{.Name}}AuthMap maps a field to the corresponding read " +
		"privacy policy.\n" +
		"var {{.Name}}AuthMap = map[string]policies.PrivacyPolicy{\n" +
		"{{range .Fields}}" +
		"\t\"{{.Name}}\": privacy.{{.Privacy.GetName}},\n" +
		"{{end}}" +
		"}\n" +
		"\n" +
		"// {{.Name}}WriteAuthMap maps a field to the corresponding write privacy " +
		"policy.\n" +
		"var {{.Name}}WriteAuthMap = map[string]policies.PrivacyPolicy{\n" +
		"{{range .Fields}}" +
		"\t\"{{.Name}}\": privacy.{{.WritePrivacy.GetName}},\n" +
		"{{end}}" +
		"}\n" +
		"\n" +
		"// {{.Name}}DeleteAuth is the privacy policy for deleting the node.\n" +
		"var {{.Name}}DeleteAuth = privacy.{{.DeletionPrivacy.GetName}}\n" +
		"\n"
	return cg.ExecTemplate(template, "edge_auth_map", data)
}

// GetEdgeFieldQueryStr creates a function that generates a query for the
// specified fields.
func GetEdgeFieldQueryStr(s cg.Schema, e cg.EdgeStruct) string {
	fields := e.Fields
	fromVar := strings.ToLower(string(e.FromNode.GetName()[0])) + "id"
	toVar := strings.ToLower(string(e.ToNode.GetName()[0])) + "id"

	data := struct {
		Name    string
		Fields  []cg.EdgeFieldStruct
		FromVar string
		ToVar   string
	}{
		Name:    e.CodeName,
		Fields:  fields,
		FromVar: fromVar,
		ToVar:   toVar,
	}
	template := "func create{{.Name}}FieldQuery(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\t{{.FromVar}} string,\n" +
		"\t{{.ToVar}} string,\n" +
		"\tfields []string,\n" +
		"\tq *models.{{.Name}}Q,\n" +
		") (*models.{{.Name}}Q, []bool, error) {\n" +
		"\n" +
		"\t// Check the auth for the fields\n" +
		"\tfieldCheck := make([]bool, len(fields))\n" +
		"\tfor i := range fields {\n" +
		"\tfieldCheck[i] = true\n" +
		"\t}" +
		"\n" +
		"\t// Add the fields to the query if appropriate auth\n" +
		"\tfor i, x := range fields {\n" +
		"\t\tvar hasAuth bool\n" +
		"\t\tvar err error\n" +
		"\t\tif pp, ok := {{$.Name}}AuthMap[x]; !ok {\n" +
		"\t\t\tlog.Warnf(\"invalid requested field: %%s-%%s\", \"{{$.Name}}\", " +
		"x)\n" +
		"\t\t\tfieldCheck[i] = false\n" +
		"\t\t} else {\n" +
		"\t\t\thasAuth, err = util.CheckEdgeAuth(conn, vc, pp, params, " +
		"\"{{$.Name}}\", {{$.FromVar}}, {{$.ToVar}})\n" +
		"\t\t\tif err != nil {\n" +
		"\t\t\t\treturn nil, nil, err\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t\tif !hasAuth {\n" +
		"\t\t\tfieldCheck[i] = false\n" +
		"\t\t} else {\n" +
		"\t\t\tswitch x {\n\n" +
		"{{range .Fields}}" +
		"\t\t\tcase \"{{.Name}}\":\n" +
		"\t\t\t\tq = q.Return{{.CodeName}}()\n" +
		"{{end}}" +
		"\t\t\tdefault:\n" +
		"\t\t\t\t{\n" +
		"\t\t\t\t\tfieldCheck[i] = false\n" +
		"\t\t\t\t\tlog.Warnf(\"invalid requested field: %%s-%%s\", \"{{$.Name}}\", " +
		"x)\n" +
		"\t\t\t\t}\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t}\n" +
		"\treturn q, fieldCheck, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_field_query", data)
}

// GetEdgeGetByIDStr generates the the function that retrieves edge fields.
func GetEdgeGetByIDStr(s cg.Schema, e cg.EdgeStruct) string {
	fields := e.Fields
	fromVar := strings.ToLower(string(e.FromNode.GetName()[0])) + "id"
	toVar := strings.ToLower(string(e.ToNode.GetName()[0])) + "id"

	data := struct {
		Name    string
		Fields  []cg.EdgeFieldStruct
		From    string
		To      string
		FromVar string
		ToVar   string
	}{
		Name:    e.CodeName,
		Fields:  fields,
		From:    e.FromNode.GetName(),
		To:      e.ToNode.GetName(),
		FromVar: fromVar,
		ToVar:   toVar,
	}
	template := "// Get{{.Name}}ByID retrives the fields of a specific " +
		"{{.Name}}.\n" +
		"// If there is insufficient authorization, the field will return null.\n" +
		"func Get{{.Name}}ByID(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\tfields []string,\n" +
		") ([]interface{}, error) {\n" +
		"\n" +
		"\t// Find the {{.FromVar}} and {{.ToVar}}\n" +
		"\trow, err := models.{{.From}}Query().\n" +
		"\t\tReturnID().\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\t\tWhereID(p.Equals(id)).\n" +
		"\t\tQuery{{.To}}().\n" +
		"\t\tReturnID().\n" +
		"\t\tGenOne(conn)\n" +
		"\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif row == nil || row[0] == nil || row[1] == nil {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\t{{.FromVar}} := row[0].(string)\n" +
		"\t{{.ToVar}} := row[1].(string)\n" +
		"\n" +
		"\t// Create the query\n" +
		"\tq := models.{{.From}}Query().\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\t\tWhereID(p.Equals(id))\n" +
		"\tq, fieldCheck, err := create{{.Name}}FieldQuery(\n\t\tconn,\n\t\tvc, " +
		"\n\t\tparams,\n\t\tid,\n\t\t{{.FromVar}},\n\t\t{{.ToVar}},\n\t\tfields, " +
		"\n\t\tq,\n)\n" +
		"\tif err != nil {\n" +
		"\t return nil, err\n" +
		"\t}\n" +
		"\n" +
		"\tif len(q.Return) == 0 {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\n" +
		"\t// Execute the query\n" +
		"\trow = nil\n" +
		"\tfor i := 0; row == nil && i < constants.LogicRetryCount; i++ {\n" +
		"\t\trow, err = q.GenOne(conn)\n" +
		"\t\t// Try a new connection\n" +
		"\t\ttime.Sleep(time.Millisecond * constants.LogicRetryWait)\n" +
		"\t\tconn.Refresh()\n" +
		"\t}\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\t// Check for the authed fields\n" +
		"\tresults := util.RemoveUnauthedFields(row, fieldCheck)\n" +
		"\n" +
		"\treturn results, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_by_id", data)
}

// GetEdgeGetByIDBatcherStr creates the batcher function for GetEdgeByID
func GetEdgeGetByIDBatcherStr(s cg.Schema, e cg.EdgeStruct) string {
	fields := e.Fields
	fromVar := strings.ToLower(string(e.FromNode.GetName()[0])) + "id"
	toVar := strings.ToLower(string(e.ToNode.GetName()[0])) + "id"

	data := struct {
		Name    string
		Fields  []cg.EdgeFieldStruct
		From    string
		To      string
		FromVar string
		ToVar   string
	}{
		Name:    e.CodeName,
		Fields:  fields,
		From:    e.FromNode.GetName(),
		To:      e.ToNode.GetName(),
		FromVar: fromVar,
		ToVar:   toVar,
	}
	template := "// Get{{.Name}}ByIDBatcher wraps the Get{{.Name}}ByID to be " +
		"batched later.\n" +
		"func Get{{.Name}}ByIDBatcher(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\tfields []string,\n" +
		") (*util.LogicGetWrapper, error) {\n" +
		"\n" +
		"\t// Find the {{.FromVar}} and {{.ToVar}}\n" +
		"\trow, err := models.{{.From}}Query().\n" +
		"\t\tReturnID().\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\t\tWhereID(p.Equals(id)).\n" +
		"\t\tQuery{{.To}}().\n" +
		"\t\tReturnID().\n" +
		"\t\tGenOne(conn)\n" +
		"\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif row == nil || row[0] == nil || row[1] == nil {\n" +
		"\t\treturn nil, errors.New(\"no such edges\")\n" +
		"\t}\n" +
		"\t{{.FromVar}} := row[0].(string)\n" +
		"\t{{.ToVar}} := row[1].(string)\n" +
		"\n" +
		"\t// Create the query\n" +
		"\tq := models.{{.From}}Query().\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\tWhereID(p.Equals(id))\n" +
		"\tq, fieldCheck, err := create{{.Name}}FieldQuery(\n\t\tconn,\n\t\tvc, " +
		"\n\t\tparams,\n\t\tid,\n\t\t{{.FromVar}},\n\t\t{{.ToVar}},\n\t\tfields, " +
		"\n\t\tq,\n)\n" +
		"\tif err != nil {\n" +
		"\t return nil, err\n" +
		"\t}\n" +
		"\n" +
		"\tbatcher := new(util.LogicGetWrapper)\n" +
		"\tbatcher.Query = &q.Query\n" +
		"\tbatcher.EvalAuth = func(row []interface{}) []interface{} {\n" +
		"\t\treturn util.RemoveUnauthedFields(row, fieldCheck)\n" +
		"\t}\n" +
		"\treturn batcher, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_by_id_batcher", data)
}

// GetEdgeGetByIDsStr generates the function that gets fields on an edge.
func GetEdgeGetByIDsStr(s cg.Schema, e cg.EdgeStruct) string {
	fields := e.Fields
	fromIDVar := strings.ToLower(string(e.FromNode.GetName()[0])) + "id"
	toIDVar := strings.ToLower(string(e.ToNode.GetName()[0])) + "id"
	fromNode := e.FromNode.GetName()
	toNode := e.ToNode.GetName()

	data := struct {
		Name      string
		Fields    []cg.EdgeFieldStruct
		FromIDVar string
		ToIDVar   string
		FromNode  string
		ToNode    string
	}{
		Name:      e.CodeName,
		Fields:    fields,
		FromIDVar: fromIDVar,
		ToIDVar:   toIDVar,
		FromNode:  fromNode,
		ToNode:    toNode,
	}
	template := "// Get{{.Name}}ByIDs retrives the fields of a specific " +
		"{{.Name}}.\n" +
		"// If there is insufficient authorization, the field will return null.\n" +
		"func Get{{.Name}}ByIDs(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\t{{.FromIDVar}} string,\n" +
		"\t{{.ToIDVar}} string,\n" +
		"\tfields []string,\n" +
		") ([]interface{}, error) {\n" +
		"\n" +
		"\t// Find the ID\n" +
		"\trow, err := models.{{.FromNode}}Query().\n" +
		"\t\tWhereID(p.Equals({{.FromIDVar}})).\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\t\tReturnID().\n" +
		"\t\tQuery{{.ToNode}}().\n" +
		"\t\tWhereID(p.Equals({{.ToIDVar}})).\n" +
		"\t\tGenOne(conn)\n" +
		"\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif row == nil || row[0] == nil {\n" +
		"\t\treturn nil, errors.New(\"no such edge\")\n" +
		"\t}\n" +
		"\tid := row[0].(string)\n" +
		"\n" +
		"\t// Create the query\n" +
		"\tq := models.{{.FromNode}}Query().\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\tWhereID(p.Equals(id))\n" +
		"\tq, fieldCheck, err := create{{.Name}}FieldQuery(\n\t\tconn,\n\t\tvc, " +
		"\n\t\tparams,\n\t\tid,\n\t\t{{$.FromIDVar}},\n\t\t{{$.ToIDVar}}, " +
		"\n\t\tfields,\n\t\tq,\n)\n" +
		"\tif err != nil {\n" +
		"\t return nil, err\n" +
		"\t}\n" +
		"\n" +
		"\tif len(q.Return) == 0 {\n" +
		"\t\treturn nil, nil\n" +
		"\t}\n" +
		"\n" +
		"\t// Execute the query\n" +
		"\trow = nil\n" +
		"\tfor i := 0; row == nil && i < constants.LogicRetryCount; i++ {\n" +
		"\t\trow, err = q.GenOne(conn)\n" +
		"\t\t// Try a new connection\n" +
		"\t\ttime.Sleep(time.Millisecond * constants.LogicRetryWait)\n" +
		"\t\tconn.Close()\n" +
		"\t}\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\t// Check for the authed fields\n" +
		"\tresults := util.RemoveUnauthedFields(row, fieldCheck)\n" +
		"\n" +
		"\treturn results, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_by_ids", data)
}

// GetEdgeGetByIDsBatcherStr creates the batcher function for GetEdgeByIDs
func GetEdgeGetByIDsBatcherStr(s cg.Schema, e cg.EdgeStruct) string {
	fields := e.Fields
	fromIDVar := strings.ToLower(string(e.FromNode.GetName()[0])) + "id"
	toIDVar := strings.ToLower(string(e.ToNode.GetName()[0])) + "id"
	fromNode := e.FromNode.GetName()
	toNode := e.ToNode.GetName()

	data := struct {
		Name      string
		Fields    []cg.EdgeFieldStruct
		FromIDVar string
		ToIDVar   string
		FromNode  string
		ToNode    string
	}{
		Name:      e.CodeName,
		Fields:    fields,
		FromIDVar: fromIDVar,
		ToIDVar:   toIDVar,
		FromNode:  fromNode,
		ToNode:    toNode,
	}
	template := "// Get{{.Name}}ByIDsBatcher wraps the Get{{.Name}}ByIDs to be " +
		"batched later.\n" +
		"// If there is insufficient authorization, the field will return null.\n" +
		"func Get{{.Name}}ByIDsBatcher(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\t{{.FromIDVar}} string,\n" +
		"\t{{.ToIDVar}} string,\n" +
		"\tfields []string,\n" +
		") (*util.LogicGetWrapper, error) {\n" +
		"\n" +
		"\t// Find the ID\n" +
		"\trow, err := models.{{.FromNode}}Query().\n" +
		"\t\tWhereID(p.Equals({{.FromIDVar}})).\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\t\tReturnID().\n" +
		"\t\tQuery{{.ToNode}}().\n" +
		"\t\tWhereID(p.Equals({{.ToIDVar}})).\n" +
		"\t\tGenOne(conn)\n" +
		"\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif row == nil || row[0] == nil {\n" +
		"\t\treturn nil, errors.New(\"no such edge\")\n" +
		"\t}\n" +
		"\tid := row[0].(string)\n" +
		"\n" +
		"\t// Create the query\n" +
		"\tq := models.{{.FromNode}}Query().\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\t\tWhereID(p.Equals(id))\n" +
		"\tq, fieldCheck, err := create{{.Name}}FieldQuery(\n\t\tconn,\n\t\tvc, " +
		"\n\t\tparams,\n\t\tid,\n\t\t{{$.FromIDVar}},\n\t\t{{$.ToIDVar}}, " +
		"\n\t\tfields,\n\t\tq,\n)\n" +
		"\tif err != nil {\n" +
		"\t return nil, err\n" +
		"\t}\n" +
		"\n" +
		"\tbatcher := new(util.LogicGetWrapper)\n" +
		"\tbatcher.Query = &q.Query\n" +
		"\tbatcher.EvalAuth = func(row []interface{}) []interface{} {\n" +
		"\t\treturn util.RemoveUnauthedFields(row, fieldCheck)\n" +
		"\t}\n" +
		"\treturn batcher, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_by_ids_batcher", data)
}

// GetEdgeWriteFieldQueryStr creates a function that generates a query for the
// updating of fields.
func GetEdgeWriteFieldQueryStr(s cg.Schema, e cg.EdgeStruct) string {
	fields := e.Fields
	fromVar := strings.ToLower(string(e.FromNode.GetName()[0])) + "id"
	toVar := strings.ToLower(string(e.ToNode.GetName()[0])) + "id"

	data := struct {
		Name    string
		Fields  []cg.EdgeFieldStruct
		FromVar string
		ToVar   string
	}{
		Name:    e.CodeName,
		Fields:  fields,
		FromVar: fromVar,
		ToVar:   toVar,
	}
	template := "func create{{.Name}}WriteFieldQuery(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\t{{.FromVar}} string,\n" +
		"\t{{.ToVar}} string,\n" +
		"\tfields map[string]interface{},\n" +
		"\tq *models.{{.Name}}M,\n" +
		") (*models.{{.Name}}M, []string, error) {\n" +
		"\n" +
		"\t// Keep track of the mutated fields\n" +
		"\tmutatedFields := []string{}\n" +
		"\n" +
		"\t// Add the fields to the query if appropriate auth\n" +
		"\tfor field, x := range fields {\n" +
		"\t\tvar hasAuth bool\n" +
		"\t\tvar err error\n" +
		"\t\tif pp, ok := {{$.Name}}AuthMap[field]; !ok {\n" +
		"\t\t\tlog.Warnf(\"invalid requested field: %%s-%%s\", \"{{$.Name}}\", " +
		"field)\n" +
		"\t\t} else {\n" +
		"\t\t\thasAuth, err = util.CheckEdgeAuth(conn, vc, pp, params, " +
		"\"{{$.Name}}\", {{$.FromVar}}, {{$.ToVar}})\n" +
		"\t\t\tif err != nil {\n" +
		"\t\t\t\treturn nil, nil, err\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t\tif hasAuth {\n" +
		"\t\t\tswitch field {\n\n" +
		"{{range .Fields}}" +
		"\t\tcase \"{{.Name}}\":\n" +
		"\t\t\t\t\tq = q.Set{{.CodeName}}(x.({{.Type}}))\n" +
		"{{end}}" +
		"\t\tdefault:\n" +
		"\t\t\t{\n" +
		"\t\t\t\tlog.Warnf(\"invalid requested field: %%s-%%s\", \"{{$.Name}}\", " +
		"x)\n" +
		"\t\t\t}\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t}\n" +
		"\treturn q, mutatedFields, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_write_field_query", data)
}

// GetUpdateEdgeGetByIDStr generates the the function that updates edge fields.
func GetUpdateEdgeGetByIDStr(s cg.Schema, e cg.EdgeStruct) string {
	fields := e.Fields
	fromVar := strings.ToLower(string(e.FromNode.GetName()[0])) + "id"
	toVar := strings.ToLower(string(e.ToNode.GetName()[0])) + "id"

	data := struct {
		Name    string
		Fields  []cg.EdgeFieldStruct
		From    string
		To      string
		FromVar string
		ToVar   string
	}{
		Name:    e.CodeName,
		Fields:  fields,
		From:    e.FromNode.GetName(),
		To:      e.ToNode.GetName(),
		FromVar: fromVar,
		ToVar:   toVar,
	}
	template := "// Update{{.Name}}ByID updates the fields of a specific " +
		"{{.Name}}.\n" +
		"// If there is insufficient authorization, the field will not be " +
		"mutated\n" +
		"func Update{{.Name}}ByID(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\tid string,\n" +
		"\tfields map[string]interface{},\n" +
		") ([]string, error) {\n" +
		"\n" +
		"\t// Find the {{.FromVar}} and {{.ToVar}}\n" +
		"\trow, err := models.{{.From}}Query().\n" +
		"\t\tReturnID().\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\t\tWhereID(p.Equals(id)).\n" +
		"\t\tQuery{{.To}}().\n" +
		"\t\tReturnID().\n" +
		"\t\tGenOne(conn)\n" +
		"\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif row == nil || row[0] == nil || row[1] == nil {\n" +
		"\t\treturn nil, errors.New(\"no such edges\")\n" +
		"\t}\n" +
		"\t{{.FromVar}} := row[0].(string)\n" +
		"\t{{.ToVar}} := row[1].(string)\n" +
		"\n" +
		"\t// Create the query\n" +
		"\tq := models.{{.Name}}Mutator(id, {{.FromVar}}, {{.ToVar}})\n" +
		"\tq, mutatedFields, err := create{{.Name}}WriteFieldQuery(\n\t\tconn," +
		"\n\t\tvc, " +
		"\n\t\tparams,\n\t\tid,\n\t\t{{.FromVar}},\n\t\t{{.ToVar}},\n\t\tfields, " +
		"\n\t\tq,\n\t)\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\t// Execute the query\n" +
		"\tvar row2 interface{}\n" +
		"\tfor i := 0; row2 == nil && i < constants.LogicRetryCount; i++ {\n" +
		"\t\trow2, _, err = q.Gen(conn)\n" +
		"\t\t// Try a new connection\n" +
		"\t\ttime.Sleep(time.Millisecond * constants.LogicRetryWait)\n" +
		"\t\tconn.Refresh()\n" +
		"\t}\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\treturn mutatedFields, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_write_by_id", data)
}

// GetUpdateEdgeGetByIDsStr generates the function that updates fields on an
// edge.
func GetUpdateEdgeGetByIDsStr(s cg.Schema, e cg.EdgeStruct) string {
	fields := e.Fields
	fromIDVar := strings.ToLower(string(e.FromNode.GetName()[0])) + "id"
	toIDVar := strings.ToLower(string(e.ToNode.GetName()[0])) + "id"
	fromNode := e.FromNode.GetName()
	toNode := e.ToNode.GetName()

	data := struct {
		Name      string
		Fields    []cg.EdgeFieldStruct
		FromIDVar string
		ToIDVar   string
		FromNode  string
		ToNode    string
	}{
		Name:      e.CodeName,
		Fields:    fields,
		FromIDVar: fromIDVar,
		ToIDVar:   toIDVar,
		FromNode:  fromNode,
		ToNode:    toNode,
	}
	template := "// Update{{.Name}}ByIDs updates the fields of a specific " +
		"{{.Name}}.\n" +
		"// If there is insufficient authorization, the field will not be " +
		"mutated.\n" +
		"func Update{{.Name}}ByIDs(\n" +
		"\tconn *db.Conn,\n" +
		"\tvc contexts.ViewerContext,\n" +
		"\tparams context.Context,\n" +
		"\t{{.FromIDVar}} string,\n" +
		"\t{{.ToIDVar}} string,\n" +
		"\tfields map[string]interface{},\n" +
		") ([]string, error) {\n" +
		"\n" +
		"\t// Find the ID\n" +
		"\trow, err := models.{{.FromNode}}Query().\n" +
		"\t\tWhereID(p.Equals({{.FromIDVar}})).\n" +
		"\t\tQuery{{.Name}}().\n" +
		"\t\tReturnID().\n" +
		"\t\tQuery{{.ToNode}}().\n" +
		"\t\tWhereID(p.Equals({{.ToIDVar}})).\n" +
		"\t\tGenOne(conn)\n" +
		"\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\tif row == nil || row[0] == nil {\n" +
		"\t\treturn nil, errors.New(\"no such edge\")\n" +
		"\t}\n" +
		"\tid := row[0].(string)\n" +
		"\n" +
		"\t// Create the query\n" +
		"\tq := models.{{.Name}}Mutator(id, {{.FromIDVar}}, {{.ToIDVar}})\n" +
		"\tq, mutatedFields, err := create{{.Name}}WriteFieldQuery(\n\t\tconn," +
		"\n\t\tvc, " +
		"\n\t\tparams,\n\t\tid,\n\t\t{{$.FromIDVar}},\n\t\t{{$.ToIDVar}}, " +
		"\n\t\tfields,\n\t\tq,\n\t)\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\t// Execute the query\n" +
		"\tvar row2 interface{}\n" +
		"\tfor i := 0; row2 == nil && i < constants.LogicRetryCount; i++ {\n" +
		"\t\trow2, _, err = q.Gen(conn)\n" +
		"\t\t// Try a new connection\n" +
		"\t\ttime.Sleep(time.Millisecond * constants.LogicRetryWait)\n" +
		"\t\tconn.Close()\n" +
		"\t}\n" +
		"\tif err != nil {\n" +
		"\t\treturn nil, err\n" +
		"\t}\n" +
		"\n" +
		"\treturn mutatedFields, nil\n" +
		"}\n"
	return cg.ExecTemplate(template, "edge_write_by_ids", data)
}
